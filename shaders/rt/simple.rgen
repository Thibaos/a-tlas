#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
#include "deps.glsl"

layout(location = 0) rayPayloadEXT MainPassPayload payload;
layout(location = 1) rayPayloadEXT TPayload shadow_payload;

// layout(set = 0, binding = 0) uniform accelerationStructureEXT static_as;
// layout(set = 0, binding = 1) uniform accelerationStructureEXT bodies_as;

// layout(set = 1, binding = 0) uniform _Camera { Camera camera; };

// layout(set = 2, binding = 0, rgba32f) uniform image2D image;

float saturate(float x) {
    return clamp(x, 0.0, 1.0);
}

vec3 viridis_quintic(float x) {
    x = saturate(x);
    vec4 x1 = vec4(1.0, x, x * x, x * x * x); // 1 x x2 x3
    vec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7
    return vec3(
        dot(x1.xyzw, vec4(+0.280268003, -0.143510503, +2.225793877, -14.815088879)) + dot(x2.xy, vec2(+25.212752309, -11.772589584)),
        dot(x1.xyzw, vec4(-0.002117546, +1.617109353, -1.909305070, +2.701152864)) + dot(x2.xy, vec2(-1.685288385, +0.178738871)),
        dot(x1.xyzw, vec4(+0.300805501, +2.614650302, -12.019139090, +28.933559110)) + dot(x2.xy, vec2(-33.491294770, +13.762053843)));
}

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    const vec2 ndc = in_uv * 2.0 - 1.0;

    const vec4 clip_pos = vec4(ndc, -1.0, 1.0);
    vec4 eye_pos = camera.proj_inverse * clip_pos;
    eye_pos /= eye_pos.w;

    const vec3 origin = (camera.view_inverse * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    const vec3 direction = normalize((camera.view_inverse * vec4(eye_pos.xyz, 0.0)).xyz);

    const uint ray_flags = gl_RayFlagsOpaqueEXT;

    vec4 final_color = vec4(0.0);

    payload.color = vec4(0.0);
    payload.t = -1.0;

    traceRayEXT(vko_accelerationStructureEXT(acceleration_structure_id), ray_flags, 0xFFu, 0u, 0u, 0u, origin, EPSILON, direction, FLT_MAX, 0);

    final_color += payload.color;

    // vec3 primary_hit_position = origin + (payload.t - EPSILON) * direction;

    {
        // shadow ray
        shadow_payload.t = -1.0;

        // traceRayEXT(vko_accelerationStructureEXT(acceleration_structure_id), gl_RayFlagsTerminateOnFirstHitEXT, 0xFFu, 0u, 0u, 0u, primary_hit_position, EPSILON, -sunlight.direction, FLT_MAX, 1);
    }

    // if (shadow_payload.t > EPSILON) {
    // final_color *= 0.25;
    // }

    imageStore(vko_image2D_rgba8(image_id), ivec2(gl_LaunchIDEXT.xy), final_color);
}
